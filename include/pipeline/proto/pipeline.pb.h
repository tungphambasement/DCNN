// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/pipeline.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fpipeline_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fpipeline_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fpipeline_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fpipeline_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2fpipeline_2eproto;
namespace tpipeline {
namespace proto {
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class StageConfig;
struct StageConfigDefaultTypeInternal;
extern StageConfigDefaultTypeInternal _StageConfig_default_instance_;
class Task;
struct TaskDefaultTypeInternal;
extern TaskDefaultTypeInternal _Task_default_instance_;
class Tensor;
struct TensorDefaultTypeInternal;
extern TensorDefaultTypeInternal _Tensor_default_instance_;
}  // namespace proto
}  // namespace tpipeline
PROTOBUF_NAMESPACE_OPEN
template<> ::tpipeline::proto::Message* Arena::CreateMaybeMessage<::tpipeline::proto::Message>(Arena*);
template<> ::tpipeline::proto::StageConfig* Arena::CreateMaybeMessage<::tpipeline::proto::StageConfig>(Arena*);
template<> ::tpipeline::proto::Task* Arena::CreateMaybeMessage<::tpipeline::proto::Task>(Arena*);
template<> ::tpipeline::proto::Tensor* Arena::CreateMaybeMessage<::tpipeline::proto::Tensor>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tpipeline {
namespace proto {

enum TaskType : int {
  FORWARD = 0,
  BACKWARD = 1,
  TaskType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TaskType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TaskType_IsValid(int value);
constexpr TaskType TaskType_MIN = FORWARD;
constexpr TaskType TaskType_MAX = BACKWARD;
constexpr int TaskType_ARRAYSIZE = TaskType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TaskType_descriptor();
template<typename T>
inline const std::string& TaskType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TaskType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TaskType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TaskType_descriptor(), enum_t_value);
}
inline bool TaskType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TaskType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TaskType>(
    TaskType_descriptor(), name, value);
}
enum CommandType : int {
  FORWARD_TASK = 0,
  BACKWARD_TASK = 1,
  UPDATE_PARAMETERS = 2,
  TRAIN_MODE = 3,
  EVAL_MODE = 4,
  SHUTDOWN = 5,
  HANDSHAKE_REQUEST = 6,
  HANDSHAKE_RESPONSE = 7,
  CONFIG_TRANSFER = 8,
  CONFIG_RECEIVED = 9,
  WEIGHTS_TRANSFER = 10,
  WEIGHTS_RECEIVED = 11,
  STATUS_REQUEST = 12,
  STATUS_RESPONSE = 13,
  PARAMETERS_UPDATED = 14,
  HEALTH_CHECK = 15,
  ERROR_REPORT = 16,
  TASK_FAILURE = 17,
  BARRIER_SYNC = 18,
  CommandType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CommandType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CommandType_IsValid(int value);
constexpr CommandType CommandType_MIN = FORWARD_TASK;
constexpr CommandType CommandType_MAX = BARRIER_SYNC;
constexpr int CommandType_ARRAYSIZE = CommandType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CommandType_descriptor();
template<typename T>
inline const std::string& CommandType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CommandType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CommandType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CommandType_descriptor(), enum_t_value);
}
inline bool CommandType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommandType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CommandType>(
    CommandType_descriptor(), name, value);
}
// ===================================================================

class Tensor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tpipeline.proto.Tensor) */ {
 public:
  inline Tensor() : Tensor(nullptr) {}
  ~Tensor() override;
  explicit PROTOBUF_CONSTEXPR Tensor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tensor(const Tensor& from);
  Tensor(Tensor&& from) noexcept
    : Tensor() {
    *this = ::std::move(from);
  }

  inline Tensor& operator=(const Tensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tensor& operator=(Tensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tensor* internal_default_instance() {
    return reinterpret_cast<const Tensor*>(
               &_Tensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Tensor& a, Tensor& b) {
    a.Swap(&b);
  }
  inline void Swap(Tensor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tensor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tensor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tensor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tensor& from) {
    Tensor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tensor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tpipeline.proto.Tensor";
  }
  protected:
  explicit Tensor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 1,
    kDataFieldNumber = 2,
    kDtypeFieldNumber = 3,
  };
  // repeated uint32 shape = 1;
  int shape_size() const;
  private:
  int _internal_shape_size() const;
  public:
  void clear_shape();
  private:
  uint32_t _internal_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_shape() const;
  void _internal_add_shape(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_shape();
  public:
  uint32_t shape(int index) const;
  void set_shape(int index, uint32_t value);
  void add_shape(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_shape();

  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string dtype = 3;
  void clear_dtype();
  const std::string& dtype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dtype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dtype();
  PROTOBUF_NODISCARD std::string* release_dtype();
  void set_allocated_dtype(std::string* dtype);
  private:
  const std::string& _internal_dtype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dtype(const std::string& value);
  std::string* _internal_mutable_dtype();
  public:

  // @@protoc_insertion_point(class_scope:tpipeline.proto.Tensor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > shape_;
    mutable std::atomic<int> _shape_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fpipeline_2eproto;
};
// -------------------------------------------------------------------

class Task final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tpipeline.proto.Task) */ {
 public:
  inline Task() : Task(nullptr) {}
  ~Task() override;
  explicit PROTOBUF_CONSTEXPR Task(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Task(const Task& from);
  Task(Task&& from) noexcept
    : Task() {
    *this = ::std::move(from);
  }

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  inline Task& operator=(Task&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Task& default_instance() {
    return *internal_default_instance();
  }
  static inline const Task* internal_default_instance() {
    return reinterpret_cast<const Task*>(
               &_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Task& a, Task& b) {
    a.Swap(&b);
  }
  inline void Swap(Task* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Task* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Task* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Task>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Task& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Task& from) {
    Task::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Task* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tpipeline.proto.Task";
  }
  protected:
  explicit Task(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kTypeFieldNumber = 1,
    kMicroBatchIdFieldNumber = 3,
  };
  // .tpipeline.proto.Tensor data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::tpipeline::proto::Tensor& data() const;
  PROTOBUF_NODISCARD ::tpipeline::proto::Tensor* release_data();
  ::tpipeline::proto::Tensor* mutable_data();
  void set_allocated_data(::tpipeline::proto::Tensor* data);
  private:
  const ::tpipeline::proto::Tensor& _internal_data() const;
  ::tpipeline::proto::Tensor* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::tpipeline::proto::Tensor* data);
  ::tpipeline::proto::Tensor* unsafe_arena_release_data();

  // .tpipeline.proto.TaskType type = 1;
  void clear_type();
  ::tpipeline::proto::TaskType type() const;
  void set_type(::tpipeline::proto::TaskType value);
  private:
  ::tpipeline::proto::TaskType _internal_type() const;
  void _internal_set_type(::tpipeline::proto::TaskType value);
  public:

  // uint32 micro_batch_id = 3;
  void clear_micro_batch_id();
  uint32_t micro_batch_id() const;
  void set_micro_batch_id(uint32_t value);
  private:
  uint32_t _internal_micro_batch_id() const;
  void _internal_set_micro_batch_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tpipeline.proto.Task)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::tpipeline::proto::Tensor* data_;
    int type_;
    uint32_t micro_batch_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fpipeline_2eproto;
};
// -------------------------------------------------------------------

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tpipeline.proto.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  explicit PROTOBUF_CONSTEXPR Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kTask = 10,
    kText = 11,
    kSignal = 12,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Message& from) {
    Message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tpipeline.proto.Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderIdFieldNumber = 3,
    kRecipientIdFieldNumber = 4,
    kCommandTypeFieldNumber = 1,
    kSequenceNumberFieldNumber = 2,
    kTimestampFieldNumber = 5,
    kTaskFieldNumber = 10,
    kTextFieldNumber = 11,
    kSignalFieldNumber = 12,
  };
  // string sender_id = 3;
  void clear_sender_id();
  const std::string& sender_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender_id();
  PROTOBUF_NODISCARD std::string* release_sender_id();
  void set_allocated_sender_id(std::string* sender_id);
  private:
  const std::string& _internal_sender_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_id(const std::string& value);
  std::string* _internal_mutable_sender_id();
  public:

  // string recipient_id = 4;
  void clear_recipient_id();
  const std::string& recipient_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recipient_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recipient_id();
  PROTOBUF_NODISCARD std::string* release_recipient_id();
  void set_allocated_recipient_id(std::string* recipient_id);
  private:
  const std::string& _internal_recipient_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipient_id(const std::string& value);
  std::string* _internal_mutable_recipient_id();
  public:

  // .tpipeline.proto.CommandType command_type = 1;
  void clear_command_type();
  ::tpipeline::proto::CommandType command_type() const;
  void set_command_type(::tpipeline::proto::CommandType value);
  private:
  ::tpipeline::proto::CommandType _internal_command_type() const;
  void _internal_set_command_type(::tpipeline::proto::CommandType value);
  public:

  // uint32 sequence_number = 2;
  void clear_sequence_number();
  uint32_t sequence_number() const;
  void set_sequence_number(uint32_t value);
  private:
  uint32_t _internal_sequence_number() const;
  void _internal_set_sequence_number(uint32_t value);
  public:

  // uint64 timestamp = 5;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // .tpipeline.proto.Task task = 10;
  bool has_task() const;
  private:
  bool _internal_has_task() const;
  public:
  void clear_task();
  const ::tpipeline::proto::Task& task() const;
  PROTOBUF_NODISCARD ::tpipeline::proto::Task* release_task();
  ::tpipeline::proto::Task* mutable_task();
  void set_allocated_task(::tpipeline::proto::Task* task);
  private:
  const ::tpipeline::proto::Task& _internal_task() const;
  ::tpipeline::proto::Task* _internal_mutable_task();
  public:
  void unsafe_arena_set_allocated_task(
      ::tpipeline::proto::Task* task);
  ::tpipeline::proto::Task* unsafe_arena_release_task();

  // string text = 11;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // bool signal = 12;
  bool has_signal() const;
  private:
  bool _internal_has_signal() const;
  public:
  void clear_signal();
  bool signal() const;
  void set_signal(bool value);
  private:
  bool _internal_signal() const;
  void _internal_set_signal(bool value);
  public:

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:tpipeline.proto.Message)
 private:
  class _Internal;
  void set_has_task();
  void set_has_text();
  void set_has_signal();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recipient_id_;
    int command_type_;
    uint32_t sequence_number_;
    uint64_t timestamp_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::tpipeline::proto::Task* task_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
      bool signal_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fpipeline_2eproto;
};
// -------------------------------------------------------------------

class StageConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tpipeline.proto.StageConfig) */ {
 public:
  inline StageConfig() : StageConfig(nullptr) {}
  ~StageConfig() override;
  explicit PROTOBUF_CONSTEXPR StageConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StageConfig(const StageConfig& from);
  StageConfig(StageConfig&& from) noexcept
    : StageConfig() {
    *this = ::std::move(from);
  }

  inline StageConfig& operator=(const StageConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline StageConfig& operator=(StageConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StageConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const StageConfig* internal_default_instance() {
    return reinterpret_cast<const StageConfig*>(
               &_StageConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StageConfig& a, StageConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(StageConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StageConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StageConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StageConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StageConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StageConfig& from) {
    StageConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StageConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tpipeline.proto.StageConfig";
  }
  protected:
  explicit StageConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStageIdFieldNumber = 1,
    kModelConfigJsonFieldNumber = 3,
    kNextStageEndpointFieldNumber = 4,
    kPrevStageEndpointFieldNumber = 5,
    kCoordinatorEndpointFieldNumber = 6,
    kStageIndexFieldNumber = 2,
  };
  // string stage_id = 1;
  void clear_stage_id();
  const std::string& stage_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stage_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stage_id();
  PROTOBUF_NODISCARD std::string* release_stage_id();
  void set_allocated_stage_id(std::string* stage_id);
  private:
  const std::string& _internal_stage_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stage_id(const std::string& value);
  std::string* _internal_mutable_stage_id();
  public:

  // string model_config_json = 3;
  void clear_model_config_json();
  const std::string& model_config_json() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_config_json(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_config_json();
  PROTOBUF_NODISCARD std::string* release_model_config_json();
  void set_allocated_model_config_json(std::string* model_config_json);
  private:
  const std::string& _internal_model_config_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_config_json(const std::string& value);
  std::string* _internal_mutable_model_config_json();
  public:

  // string next_stage_endpoint = 4;
  void clear_next_stage_endpoint();
  const std::string& next_stage_endpoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_stage_endpoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_stage_endpoint();
  PROTOBUF_NODISCARD std::string* release_next_stage_endpoint();
  void set_allocated_next_stage_endpoint(std::string* next_stage_endpoint);
  private:
  const std::string& _internal_next_stage_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_stage_endpoint(const std::string& value);
  std::string* _internal_mutable_next_stage_endpoint();
  public:

  // string prev_stage_endpoint = 5;
  void clear_prev_stage_endpoint();
  const std::string& prev_stage_endpoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prev_stage_endpoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prev_stage_endpoint();
  PROTOBUF_NODISCARD std::string* release_prev_stage_endpoint();
  void set_allocated_prev_stage_endpoint(std::string* prev_stage_endpoint);
  private:
  const std::string& _internal_prev_stage_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prev_stage_endpoint(const std::string& value);
  std::string* _internal_mutable_prev_stage_endpoint();
  public:

  // string coordinator_endpoint = 6;
  void clear_coordinator_endpoint();
  const std::string& coordinator_endpoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_coordinator_endpoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_coordinator_endpoint();
  PROTOBUF_NODISCARD std::string* release_coordinator_endpoint();
  void set_allocated_coordinator_endpoint(std::string* coordinator_endpoint);
  private:
  const std::string& _internal_coordinator_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coordinator_endpoint(const std::string& value);
  std::string* _internal_mutable_coordinator_endpoint();
  public:

  // int32 stage_index = 2;
  void clear_stage_index();
  int32_t stage_index() const;
  void set_stage_index(int32_t value);
  private:
  int32_t _internal_stage_index() const;
  void _internal_set_stage_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tpipeline.proto.StageConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stage_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_config_json_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_stage_endpoint_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prev_stage_endpoint_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coordinator_endpoint_;
    int32_t stage_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fpipeline_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Tensor

// repeated uint32 shape = 1;
inline int Tensor::_internal_shape_size() const {
  return _impl_.shape_.size();
}
inline int Tensor::shape_size() const {
  return _internal_shape_size();
}
inline void Tensor::clear_shape() {
  _impl_.shape_.Clear();
}
inline uint32_t Tensor::_internal_shape(int index) const {
  return _impl_.shape_.Get(index);
}
inline uint32_t Tensor::shape(int index) const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Tensor.shape)
  return _internal_shape(index);
}
inline void Tensor::set_shape(int index, uint32_t value) {
  _impl_.shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:tpipeline.proto.Tensor.shape)
}
inline void Tensor::_internal_add_shape(uint32_t value) {
  _impl_.shape_.Add(value);
}
inline void Tensor::add_shape(uint32_t value) {
  _internal_add_shape(value);
  // @@protoc_insertion_point(field_add:tpipeline.proto.Tensor.shape)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Tensor::_internal_shape() const {
  return _impl_.shape_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Tensor::shape() const {
  // @@protoc_insertion_point(field_list:tpipeline.proto.Tensor.shape)
  return _internal_shape();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Tensor::_internal_mutable_shape() {
  return &_impl_.shape_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Tensor::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:tpipeline.proto.Tensor.shape)
  return _internal_mutable_shape();
}

// bytes data = 2;
inline void Tensor::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Tensor::data() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Tensor.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tensor::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tpipeline.proto.Tensor.data)
}
inline std::string* Tensor::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:tpipeline.proto.Tensor.data)
  return _s;
}
inline const std::string& Tensor::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Tensor::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Tensor::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* Tensor::release_data() {
  // @@protoc_insertion_point(field_release:tpipeline.proto.Tensor.data)
  return _impl_.data_.Release();
}
inline void Tensor::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tpipeline.proto.Tensor.data)
}

// string dtype = 3;
inline void Tensor::clear_dtype() {
  _impl_.dtype_.ClearToEmpty();
}
inline const std::string& Tensor::dtype() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Tensor.dtype)
  return _internal_dtype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tensor::set_dtype(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dtype_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tpipeline.proto.Tensor.dtype)
}
inline std::string* Tensor::mutable_dtype() {
  std::string* _s = _internal_mutable_dtype();
  // @@protoc_insertion_point(field_mutable:tpipeline.proto.Tensor.dtype)
  return _s;
}
inline const std::string& Tensor::_internal_dtype() const {
  return _impl_.dtype_.Get();
}
inline void Tensor::_internal_set_dtype(const std::string& value) {
  
  _impl_.dtype_.Set(value, GetArenaForAllocation());
}
inline std::string* Tensor::_internal_mutable_dtype() {
  
  return _impl_.dtype_.Mutable(GetArenaForAllocation());
}
inline std::string* Tensor::release_dtype() {
  // @@protoc_insertion_point(field_release:tpipeline.proto.Tensor.dtype)
  return _impl_.dtype_.Release();
}
inline void Tensor::set_allocated_dtype(std::string* dtype) {
  if (dtype != nullptr) {
    
  } else {
    
  }
  _impl_.dtype_.SetAllocated(dtype, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dtype_.IsDefault()) {
    _impl_.dtype_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tpipeline.proto.Tensor.dtype)
}

// -------------------------------------------------------------------

// Task

// .tpipeline.proto.TaskType type = 1;
inline void Task::clear_type() {
  _impl_.type_ = 0;
}
inline ::tpipeline::proto::TaskType Task::_internal_type() const {
  return static_cast< ::tpipeline::proto::TaskType >(_impl_.type_);
}
inline ::tpipeline::proto::TaskType Task::type() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Task.type)
  return _internal_type();
}
inline void Task::_internal_set_type(::tpipeline::proto::TaskType value) {
  
  _impl_.type_ = value;
}
inline void Task::set_type(::tpipeline::proto::TaskType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:tpipeline.proto.Task.type)
}

// .tpipeline.proto.Tensor data = 2;
inline bool Task::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool Task::has_data() const {
  return _internal_has_data();
}
inline void Task::clear_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
}
inline const ::tpipeline::proto::Tensor& Task::_internal_data() const {
  const ::tpipeline::proto::Tensor* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::tpipeline::proto::Tensor&>(
      ::tpipeline::proto::_Tensor_default_instance_);
}
inline const ::tpipeline::proto::Tensor& Task::data() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Task.data)
  return _internal_data();
}
inline void Task::unsafe_arena_set_allocated_data(
    ::tpipeline::proto::Tensor* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tpipeline.proto.Task.data)
}
inline ::tpipeline::proto::Tensor* Task::release_data() {
  
  ::tpipeline::proto::Tensor* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tpipeline::proto::Tensor* Task::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:tpipeline.proto.Task.data)
  
  ::tpipeline::proto::Tensor* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::tpipeline::proto::Tensor* Task::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::tpipeline::proto::Tensor>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::tpipeline::proto::Tensor* Task::mutable_data() {
  ::tpipeline::proto::Tensor* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:tpipeline.proto.Task.data)
  return _msg;
}
inline void Task::set_allocated_data(::tpipeline::proto::Tensor* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:tpipeline.proto.Task.data)
}

// uint32 micro_batch_id = 3;
inline void Task::clear_micro_batch_id() {
  _impl_.micro_batch_id_ = 0u;
}
inline uint32_t Task::_internal_micro_batch_id() const {
  return _impl_.micro_batch_id_;
}
inline uint32_t Task::micro_batch_id() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Task.micro_batch_id)
  return _internal_micro_batch_id();
}
inline void Task::_internal_set_micro_batch_id(uint32_t value) {
  
  _impl_.micro_batch_id_ = value;
}
inline void Task::set_micro_batch_id(uint32_t value) {
  _internal_set_micro_batch_id(value);
  // @@protoc_insertion_point(field_set:tpipeline.proto.Task.micro_batch_id)
}

// -------------------------------------------------------------------

// Message

// .tpipeline.proto.CommandType command_type = 1;
inline void Message::clear_command_type() {
  _impl_.command_type_ = 0;
}
inline ::tpipeline::proto::CommandType Message::_internal_command_type() const {
  return static_cast< ::tpipeline::proto::CommandType >(_impl_.command_type_);
}
inline ::tpipeline::proto::CommandType Message::command_type() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Message.command_type)
  return _internal_command_type();
}
inline void Message::_internal_set_command_type(::tpipeline::proto::CommandType value) {
  
  _impl_.command_type_ = value;
}
inline void Message::set_command_type(::tpipeline::proto::CommandType value) {
  _internal_set_command_type(value);
  // @@protoc_insertion_point(field_set:tpipeline.proto.Message.command_type)
}

// uint32 sequence_number = 2;
inline void Message::clear_sequence_number() {
  _impl_.sequence_number_ = 0u;
}
inline uint32_t Message::_internal_sequence_number() const {
  return _impl_.sequence_number_;
}
inline uint32_t Message::sequence_number() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Message.sequence_number)
  return _internal_sequence_number();
}
inline void Message::_internal_set_sequence_number(uint32_t value) {
  
  _impl_.sequence_number_ = value;
}
inline void Message::set_sequence_number(uint32_t value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:tpipeline.proto.Message.sequence_number)
}

// string sender_id = 3;
inline void Message::clear_sender_id() {
  _impl_.sender_id_.ClearToEmpty();
}
inline const std::string& Message::sender_id() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Message.sender_id)
  return _internal_sender_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_sender_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sender_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tpipeline.proto.Message.sender_id)
}
inline std::string* Message::mutable_sender_id() {
  std::string* _s = _internal_mutable_sender_id();
  // @@protoc_insertion_point(field_mutable:tpipeline.proto.Message.sender_id)
  return _s;
}
inline const std::string& Message::_internal_sender_id() const {
  return _impl_.sender_id_.Get();
}
inline void Message::_internal_set_sender_id(const std::string& value) {
  
  _impl_.sender_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_sender_id() {
  
  return _impl_.sender_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_sender_id() {
  // @@protoc_insertion_point(field_release:tpipeline.proto.Message.sender_id)
  return _impl_.sender_id_.Release();
}
inline void Message::set_allocated_sender_id(std::string* sender_id) {
  if (sender_id != nullptr) {
    
  } else {
    
  }
  _impl_.sender_id_.SetAllocated(sender_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sender_id_.IsDefault()) {
    _impl_.sender_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tpipeline.proto.Message.sender_id)
}

// string recipient_id = 4;
inline void Message::clear_recipient_id() {
  _impl_.recipient_id_.ClearToEmpty();
}
inline const std::string& Message::recipient_id() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Message.recipient_id)
  return _internal_recipient_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_recipient_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.recipient_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tpipeline.proto.Message.recipient_id)
}
inline std::string* Message::mutable_recipient_id() {
  std::string* _s = _internal_mutable_recipient_id();
  // @@protoc_insertion_point(field_mutable:tpipeline.proto.Message.recipient_id)
  return _s;
}
inline const std::string& Message::_internal_recipient_id() const {
  return _impl_.recipient_id_.Get();
}
inline void Message::_internal_set_recipient_id(const std::string& value) {
  
  _impl_.recipient_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_recipient_id() {
  
  return _impl_.recipient_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_recipient_id() {
  // @@protoc_insertion_point(field_release:tpipeline.proto.Message.recipient_id)
  return _impl_.recipient_id_.Release();
}
inline void Message::set_allocated_recipient_id(std::string* recipient_id) {
  if (recipient_id != nullptr) {
    
  } else {
    
  }
  _impl_.recipient_id_.SetAllocated(recipient_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.recipient_id_.IsDefault()) {
    _impl_.recipient_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tpipeline.proto.Message.recipient_id)
}

// uint64 timestamp = 5;
inline void Message::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t Message::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t Message::timestamp() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Message.timestamp)
  return _internal_timestamp();
}
inline void Message::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void Message::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:tpipeline.proto.Message.timestamp)
}

// .tpipeline.proto.Task task = 10;
inline bool Message::_internal_has_task() const {
  return payload_case() == kTask;
}
inline bool Message::has_task() const {
  return _internal_has_task();
}
inline void Message::set_has_task() {
  _impl_._oneof_case_[0] = kTask;
}
inline void Message::clear_task() {
  if (_internal_has_task()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.task_;
    }
    clear_has_payload();
  }
}
inline ::tpipeline::proto::Task* Message::release_task() {
  // @@protoc_insertion_point(field_release:tpipeline.proto.Message.task)
  if (_internal_has_task()) {
    clear_has_payload();
    ::tpipeline::proto::Task* temp = _impl_.payload_.task_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.task_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tpipeline::proto::Task& Message::_internal_task() const {
  return _internal_has_task()
      ? *_impl_.payload_.task_
      : reinterpret_cast< ::tpipeline::proto::Task&>(::tpipeline::proto::_Task_default_instance_);
}
inline const ::tpipeline::proto::Task& Message::task() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Message.task)
  return _internal_task();
}
inline ::tpipeline::proto::Task* Message::unsafe_arena_release_task() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tpipeline.proto.Message.task)
  if (_internal_has_task()) {
    clear_has_payload();
    ::tpipeline::proto::Task* temp = _impl_.payload_.task_;
    _impl_.payload_.task_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_task(::tpipeline::proto::Task* task) {
  clear_payload();
  if (task) {
    set_has_task();
    _impl_.payload_.task_ = task;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tpipeline.proto.Message.task)
}
inline ::tpipeline::proto::Task* Message::_internal_mutable_task() {
  if (!_internal_has_task()) {
    clear_payload();
    set_has_task();
    _impl_.payload_.task_ = CreateMaybeMessage< ::tpipeline::proto::Task >(GetArenaForAllocation());
  }
  return _impl_.payload_.task_;
}
inline ::tpipeline::proto::Task* Message::mutable_task() {
  ::tpipeline::proto::Task* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:tpipeline.proto.Message.task)
  return _msg;
}

// string text = 11;
inline bool Message::_internal_has_text() const {
  return payload_case() == kText;
}
inline bool Message::has_text() const {
  return _internal_has_text();
}
inline void Message::set_has_text() {
  _impl_._oneof_case_[0] = kText;
}
inline void Message::clear_text() {
  if (_internal_has_text()) {
    _impl_.payload_.text_.Destroy();
    clear_has_payload();
  }
}
inline const std::string& Message::text() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Message.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline void Message::set_text(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_text()) {
    clear_payload();
    set_has_text();
    _impl_.payload_.text_.InitDefault();
  }
  _impl_.payload_.text_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tpipeline.proto.Message.text)
}
inline std::string* Message::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:tpipeline.proto.Message.text)
  return _s;
}
inline const std::string& Message::_internal_text() const {
  if (_internal_has_text()) {
    return _impl_.payload_.text_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Message::_internal_set_text(const std::string& value) {
  if (!_internal_has_text()) {
    clear_payload();
    set_has_text();
    _impl_.payload_.text_.InitDefault();
  }
  _impl_.payload_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_payload();
    set_has_text();
    _impl_.payload_.text_.InitDefault();
  }
  return _impl_.payload_.text_.Mutable(      GetArenaForAllocation());
}
inline std::string* Message::release_text() {
  // @@protoc_insertion_point(field_release:tpipeline.proto.Message.text)
  if (_internal_has_text()) {
    clear_has_payload();
    return _impl_.payload_.text_.Release();
  } else {
    return nullptr;
  }
}
inline void Message::set_allocated_text(std::string* text) {
  if (has_payload()) {
    clear_payload();
  }
  if (text != nullptr) {
    set_has_text();
    _impl_.payload_.text_.InitAllocated(text, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:tpipeline.proto.Message.text)
}

// bool signal = 12;
inline bool Message::_internal_has_signal() const {
  return payload_case() == kSignal;
}
inline bool Message::has_signal() const {
  return _internal_has_signal();
}
inline void Message::set_has_signal() {
  _impl_._oneof_case_[0] = kSignal;
}
inline void Message::clear_signal() {
  if (_internal_has_signal()) {
    _impl_.payload_.signal_ = false;
    clear_has_payload();
  }
}
inline bool Message::_internal_signal() const {
  if (_internal_has_signal()) {
    return _impl_.payload_.signal_;
  }
  return false;
}
inline void Message::_internal_set_signal(bool value) {
  if (!_internal_has_signal()) {
    clear_payload();
    set_has_signal();
  }
  _impl_.payload_.signal_ = value;
}
inline bool Message::signal() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Message.signal)
  return _internal_signal();
}
inline void Message::set_signal(bool value) {
  _internal_set_signal(value);
  // @@protoc_insertion_point(field_set:tpipeline.proto.Message.signal)
}

inline bool Message::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Message::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Message::PayloadCase Message::payload_case() const {
  return Message::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// StageConfig

// string stage_id = 1;
inline void StageConfig::clear_stage_id() {
  _impl_.stage_id_.ClearToEmpty();
}
inline const std::string& StageConfig::stage_id() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.StageConfig.stage_id)
  return _internal_stage_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StageConfig::set_stage_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stage_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tpipeline.proto.StageConfig.stage_id)
}
inline std::string* StageConfig::mutable_stage_id() {
  std::string* _s = _internal_mutable_stage_id();
  // @@protoc_insertion_point(field_mutable:tpipeline.proto.StageConfig.stage_id)
  return _s;
}
inline const std::string& StageConfig::_internal_stage_id() const {
  return _impl_.stage_id_.Get();
}
inline void StageConfig::_internal_set_stage_id(const std::string& value) {
  
  _impl_.stage_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StageConfig::_internal_mutable_stage_id() {
  
  return _impl_.stage_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StageConfig::release_stage_id() {
  // @@protoc_insertion_point(field_release:tpipeline.proto.StageConfig.stage_id)
  return _impl_.stage_id_.Release();
}
inline void StageConfig::set_allocated_stage_id(std::string* stage_id) {
  if (stage_id != nullptr) {
    
  } else {
    
  }
  _impl_.stage_id_.SetAllocated(stage_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stage_id_.IsDefault()) {
    _impl_.stage_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tpipeline.proto.StageConfig.stage_id)
}

// int32 stage_index = 2;
inline void StageConfig::clear_stage_index() {
  _impl_.stage_index_ = 0;
}
inline int32_t StageConfig::_internal_stage_index() const {
  return _impl_.stage_index_;
}
inline int32_t StageConfig::stage_index() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.StageConfig.stage_index)
  return _internal_stage_index();
}
inline void StageConfig::_internal_set_stage_index(int32_t value) {
  
  _impl_.stage_index_ = value;
}
inline void StageConfig::set_stage_index(int32_t value) {
  _internal_set_stage_index(value);
  // @@protoc_insertion_point(field_set:tpipeline.proto.StageConfig.stage_index)
}

// string model_config_json = 3;
inline void StageConfig::clear_model_config_json() {
  _impl_.model_config_json_.ClearToEmpty();
}
inline const std::string& StageConfig::model_config_json() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.StageConfig.model_config_json)
  return _internal_model_config_json();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StageConfig::set_model_config_json(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_config_json_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tpipeline.proto.StageConfig.model_config_json)
}
inline std::string* StageConfig::mutable_model_config_json() {
  std::string* _s = _internal_mutable_model_config_json();
  // @@protoc_insertion_point(field_mutable:tpipeline.proto.StageConfig.model_config_json)
  return _s;
}
inline const std::string& StageConfig::_internal_model_config_json() const {
  return _impl_.model_config_json_.Get();
}
inline void StageConfig::_internal_set_model_config_json(const std::string& value) {
  
  _impl_.model_config_json_.Set(value, GetArenaForAllocation());
}
inline std::string* StageConfig::_internal_mutable_model_config_json() {
  
  return _impl_.model_config_json_.Mutable(GetArenaForAllocation());
}
inline std::string* StageConfig::release_model_config_json() {
  // @@protoc_insertion_point(field_release:tpipeline.proto.StageConfig.model_config_json)
  return _impl_.model_config_json_.Release();
}
inline void StageConfig::set_allocated_model_config_json(std::string* model_config_json) {
  if (model_config_json != nullptr) {
    
  } else {
    
  }
  _impl_.model_config_json_.SetAllocated(model_config_json, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_config_json_.IsDefault()) {
    _impl_.model_config_json_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tpipeline.proto.StageConfig.model_config_json)
}

// string next_stage_endpoint = 4;
inline void StageConfig::clear_next_stage_endpoint() {
  _impl_.next_stage_endpoint_.ClearToEmpty();
}
inline const std::string& StageConfig::next_stage_endpoint() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.StageConfig.next_stage_endpoint)
  return _internal_next_stage_endpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StageConfig::set_next_stage_endpoint(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_stage_endpoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tpipeline.proto.StageConfig.next_stage_endpoint)
}
inline std::string* StageConfig::mutable_next_stage_endpoint() {
  std::string* _s = _internal_mutable_next_stage_endpoint();
  // @@protoc_insertion_point(field_mutable:tpipeline.proto.StageConfig.next_stage_endpoint)
  return _s;
}
inline const std::string& StageConfig::_internal_next_stage_endpoint() const {
  return _impl_.next_stage_endpoint_.Get();
}
inline void StageConfig::_internal_set_next_stage_endpoint(const std::string& value) {
  
  _impl_.next_stage_endpoint_.Set(value, GetArenaForAllocation());
}
inline std::string* StageConfig::_internal_mutable_next_stage_endpoint() {
  
  return _impl_.next_stage_endpoint_.Mutable(GetArenaForAllocation());
}
inline std::string* StageConfig::release_next_stage_endpoint() {
  // @@protoc_insertion_point(field_release:tpipeline.proto.StageConfig.next_stage_endpoint)
  return _impl_.next_stage_endpoint_.Release();
}
inline void StageConfig::set_allocated_next_stage_endpoint(std::string* next_stage_endpoint) {
  if (next_stage_endpoint != nullptr) {
    
  } else {
    
  }
  _impl_.next_stage_endpoint_.SetAllocated(next_stage_endpoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_stage_endpoint_.IsDefault()) {
    _impl_.next_stage_endpoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tpipeline.proto.StageConfig.next_stage_endpoint)
}

// string prev_stage_endpoint = 5;
inline void StageConfig::clear_prev_stage_endpoint() {
  _impl_.prev_stage_endpoint_.ClearToEmpty();
}
inline const std::string& StageConfig::prev_stage_endpoint() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.StageConfig.prev_stage_endpoint)
  return _internal_prev_stage_endpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StageConfig::set_prev_stage_endpoint(ArgT0&& arg0, ArgT... args) {
 
 _impl_.prev_stage_endpoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tpipeline.proto.StageConfig.prev_stage_endpoint)
}
inline std::string* StageConfig::mutable_prev_stage_endpoint() {
  std::string* _s = _internal_mutable_prev_stage_endpoint();
  // @@protoc_insertion_point(field_mutable:tpipeline.proto.StageConfig.prev_stage_endpoint)
  return _s;
}
inline const std::string& StageConfig::_internal_prev_stage_endpoint() const {
  return _impl_.prev_stage_endpoint_.Get();
}
inline void StageConfig::_internal_set_prev_stage_endpoint(const std::string& value) {
  
  _impl_.prev_stage_endpoint_.Set(value, GetArenaForAllocation());
}
inline std::string* StageConfig::_internal_mutable_prev_stage_endpoint() {
  
  return _impl_.prev_stage_endpoint_.Mutable(GetArenaForAllocation());
}
inline std::string* StageConfig::release_prev_stage_endpoint() {
  // @@protoc_insertion_point(field_release:tpipeline.proto.StageConfig.prev_stage_endpoint)
  return _impl_.prev_stage_endpoint_.Release();
}
inline void StageConfig::set_allocated_prev_stage_endpoint(std::string* prev_stage_endpoint) {
  if (prev_stage_endpoint != nullptr) {
    
  } else {
    
  }
  _impl_.prev_stage_endpoint_.SetAllocated(prev_stage_endpoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.prev_stage_endpoint_.IsDefault()) {
    _impl_.prev_stage_endpoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tpipeline.proto.StageConfig.prev_stage_endpoint)
}

// string coordinator_endpoint = 6;
inline void StageConfig::clear_coordinator_endpoint() {
  _impl_.coordinator_endpoint_.ClearToEmpty();
}
inline const std::string& StageConfig::coordinator_endpoint() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.StageConfig.coordinator_endpoint)
  return _internal_coordinator_endpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StageConfig::set_coordinator_endpoint(ArgT0&& arg0, ArgT... args) {
 
 _impl_.coordinator_endpoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tpipeline.proto.StageConfig.coordinator_endpoint)
}
inline std::string* StageConfig::mutable_coordinator_endpoint() {
  std::string* _s = _internal_mutable_coordinator_endpoint();
  // @@protoc_insertion_point(field_mutable:tpipeline.proto.StageConfig.coordinator_endpoint)
  return _s;
}
inline const std::string& StageConfig::_internal_coordinator_endpoint() const {
  return _impl_.coordinator_endpoint_.Get();
}
inline void StageConfig::_internal_set_coordinator_endpoint(const std::string& value) {
  
  _impl_.coordinator_endpoint_.Set(value, GetArenaForAllocation());
}
inline std::string* StageConfig::_internal_mutable_coordinator_endpoint() {
  
  return _impl_.coordinator_endpoint_.Mutable(GetArenaForAllocation());
}
inline std::string* StageConfig::release_coordinator_endpoint() {
  // @@protoc_insertion_point(field_release:tpipeline.proto.StageConfig.coordinator_endpoint)
  return _impl_.coordinator_endpoint_.Release();
}
inline void StageConfig::set_allocated_coordinator_endpoint(std::string* coordinator_endpoint) {
  if (coordinator_endpoint != nullptr) {
    
  } else {
    
  }
  _impl_.coordinator_endpoint_.SetAllocated(coordinator_endpoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.coordinator_endpoint_.IsDefault()) {
    _impl_.coordinator_endpoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tpipeline.proto.StageConfig.coordinator_endpoint)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace tpipeline

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::tpipeline::proto::TaskType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tpipeline::proto::TaskType>() {
  return ::tpipeline::proto::TaskType_descriptor();
}
template <> struct is_proto_enum< ::tpipeline::proto::CommandType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tpipeline::proto::CommandType>() {
  return ::tpipeline::proto::CommandType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2fpipeline_2eproto
