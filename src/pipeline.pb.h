// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: pipeline.proto
// Protobuf C++ Version: 5.29.5

#ifndef pipeline_2eproto_2epb_2eh
#define pipeline_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029005
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_pipeline_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_pipeline_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_pipeline_2eproto;
namespace tpipeline {
namespace proto {
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class StageConfig;
struct StageConfigDefaultTypeInternal;
extern StageConfigDefaultTypeInternal _StageConfig_default_instance_;
class Task;
struct TaskDefaultTypeInternal;
extern TaskDefaultTypeInternal _Task_default_instance_;
class Tensor;
struct TensorDefaultTypeInternal;
extern TensorDefaultTypeInternal _Tensor_default_instance_;
}  // namespace proto
}  // namespace tpipeline
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace tpipeline {
namespace proto {
enum TaskType : int {
  FORWARD = 0,
  BACKWARD = 1,
  TaskType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  TaskType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool TaskType_IsValid(int value);
extern const uint32_t TaskType_internal_data_[];
constexpr TaskType TaskType_MIN = static_cast<TaskType>(0);
constexpr TaskType TaskType_MAX = static_cast<TaskType>(1);
constexpr int TaskType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
TaskType_descriptor();
template <typename T>
const std::string& TaskType_Name(T value) {
  static_assert(std::is_same<T, TaskType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to TaskType_Name().");
  return TaskType_Name(static_cast<TaskType>(value));
}
template <>
inline const std::string& TaskType_Name(TaskType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TaskType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool TaskType_Parse(absl::string_view name, TaskType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskType>(
      TaskType_descriptor(), name, value);
}
enum CommandType : int {
  FORWARD_TASK = 0,
  BACKWARD_TASK = 1,
  UPDATE_PARAMETERS = 2,
  TRAIN_MODE = 3,
  EVAL_MODE = 4,
  SHUTDOWN = 5,
  HANDSHAKE_REQUEST = 6,
  HANDSHAKE_RESPONSE = 7,
  CONFIG_TRANSFER = 8,
  CONFIG_RECEIVED = 9,
  WEIGHTS_TRANSFER = 10,
  WEIGHTS_RECEIVED = 11,
  STATUS_REQUEST = 12,
  STATUS_RESPONSE = 13,
  PARAMETERS_UPDATED = 14,
  HEALTH_CHECK = 15,
  ERROR_REPORT = 16,
  TASK_FAILURE = 17,
  BARRIER_SYNC = 18,
  CommandType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CommandType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CommandType_IsValid(int value);
extern const uint32_t CommandType_internal_data_[];
constexpr CommandType CommandType_MIN = static_cast<CommandType>(0);
constexpr CommandType CommandType_MAX = static_cast<CommandType>(18);
constexpr int CommandType_ARRAYSIZE = 18 + 1;
const ::google::protobuf::EnumDescriptor*
CommandType_descriptor();
template <typename T>
const std::string& CommandType_Name(T value) {
  static_assert(std::is_same<T, CommandType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CommandType_Name().");
  return CommandType_Name(static_cast<CommandType>(value));
}
template <>
inline const std::string& CommandType_Name(CommandType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CommandType_descriptor,
                                                 0, 18>(
      static_cast<int>(value));
}
inline bool CommandType_Parse(absl::string_view name, CommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommandType>(
      CommandType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Tensor final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tpipeline.proto.Tensor) */ {
 public:
  inline Tensor() : Tensor(nullptr) {}
  ~Tensor() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Tensor* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Tensor));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Tensor(
      ::google::protobuf::internal::ConstantInitialized);

  inline Tensor(const Tensor& from) : Tensor(nullptr, from) {}
  inline Tensor(Tensor&& from) noexcept
      : Tensor(nullptr, std::move(from)) {}
  inline Tensor& operator=(const Tensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tensor& operator=(Tensor&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tensor* internal_default_instance() {
    return reinterpret_cast<const Tensor*>(
        &_Tensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Tensor& a, Tensor& b) { a.Swap(&b); }
  inline void Swap(Tensor* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tensor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tensor* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Tensor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Tensor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Tensor& from) { Tensor::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Tensor* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tpipeline.proto.Tensor"; }

 protected:
  explicit Tensor(::google::protobuf::Arena* arena);
  Tensor(::google::protobuf::Arena* arena, const Tensor& from);
  Tensor(::google::protobuf::Arena* arena, Tensor&& from) noexcept
      : Tensor(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kShapeFieldNumber = 1,
    kDataFieldNumber = 2,
    kDtypeFieldNumber = 3,
  };
  // repeated uint32 shape = 1;
  int shape_size() const;
  private:
  int _internal_shape_size() const;

  public:
  void clear_shape() ;
  ::uint32_t shape(int index) const;
  void set_shape(int index, ::uint32_t value);
  void add_shape(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& shape() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_shape();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_shape() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_shape();

  public:
  // bytes data = 2;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // string dtype = 3;
  void clear_dtype() ;
  const std::string& dtype() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dtype(Arg_&& arg, Args_... args);
  std::string* mutable_dtype();
  PROTOBUF_NODISCARD std::string* release_dtype();
  void set_allocated_dtype(std::string* value);

  private:
  const std::string& _internal_dtype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dtype(
      const std::string& value);
  std::string* _internal_mutable_dtype();

  public:
  // @@protoc_insertion_point(class_scope:tpipeline.proto.Tensor)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      36, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Tensor& from_msg);
    ::google::protobuf::RepeatedField<::uint32_t> shape_;
    ::google::protobuf::internal::CachedSize _shape_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::google::protobuf::internal::ArenaStringPtr dtype_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pipeline_2eproto;
};
// -------------------------------------------------------------------

class StageConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tpipeline.proto.StageConfig) */ {
 public:
  inline StageConfig() : StageConfig(nullptr) {}
  ~StageConfig() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StageConfig* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StageConfig));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StageConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline StageConfig(const StageConfig& from) : StageConfig(nullptr, from) {}
  inline StageConfig(StageConfig&& from) noexcept
      : StageConfig(nullptr, std::move(from)) {}
  inline StageConfig& operator=(const StageConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline StageConfig& operator=(StageConfig&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StageConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const StageConfig* internal_default_instance() {
    return reinterpret_cast<const StageConfig*>(
        &_StageConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(StageConfig& a, StageConfig& b) { a.Swap(&b); }
  inline void Swap(StageConfig* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StageConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StageConfig* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StageConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StageConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StageConfig& from) { StageConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StageConfig* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tpipeline.proto.StageConfig"; }

 protected:
  explicit StageConfig(::google::protobuf::Arena* arena);
  StageConfig(::google::protobuf::Arena* arena, const StageConfig& from);
  StageConfig(::google::protobuf::Arena* arena, StageConfig&& from) noexcept
      : StageConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStageIdFieldNumber = 1,
    kModelConfigJsonFieldNumber = 3,
    kNextStageEndpointFieldNumber = 4,
    kPrevStageEndpointFieldNumber = 5,
    kCoordinatorEndpointFieldNumber = 6,
    kStageIndexFieldNumber = 2,
  };
  // string stage_id = 1;
  void clear_stage_id() ;
  const std::string& stage_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stage_id(Arg_&& arg, Args_... args);
  std::string* mutable_stage_id();
  PROTOBUF_NODISCARD std::string* release_stage_id();
  void set_allocated_stage_id(std::string* value);

  private:
  const std::string& _internal_stage_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stage_id(
      const std::string& value);
  std::string* _internal_mutable_stage_id();

  public:
  // string model_config_json = 3;
  void clear_model_config_json() ;
  const std::string& model_config_json() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_model_config_json(Arg_&& arg, Args_... args);
  std::string* mutable_model_config_json();
  PROTOBUF_NODISCARD std::string* release_model_config_json();
  void set_allocated_model_config_json(std::string* value);

  private:
  const std::string& _internal_model_config_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_config_json(
      const std::string& value);
  std::string* _internal_mutable_model_config_json();

  public:
  // string next_stage_endpoint = 4;
  void clear_next_stage_endpoint() ;
  const std::string& next_stage_endpoint() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_next_stage_endpoint(Arg_&& arg, Args_... args);
  std::string* mutable_next_stage_endpoint();
  PROTOBUF_NODISCARD std::string* release_next_stage_endpoint();
  void set_allocated_next_stage_endpoint(std::string* value);

  private:
  const std::string& _internal_next_stage_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_stage_endpoint(
      const std::string& value);
  std::string* _internal_mutable_next_stage_endpoint();

  public:
  // string prev_stage_endpoint = 5;
  void clear_prev_stage_endpoint() ;
  const std::string& prev_stage_endpoint() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_prev_stage_endpoint(Arg_&& arg, Args_... args);
  std::string* mutable_prev_stage_endpoint();
  PROTOBUF_NODISCARD std::string* release_prev_stage_endpoint();
  void set_allocated_prev_stage_endpoint(std::string* value);

  private:
  const std::string& _internal_prev_stage_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prev_stage_endpoint(
      const std::string& value);
  std::string* _internal_mutable_prev_stage_endpoint();

  public:
  // string coordinator_endpoint = 6;
  void clear_coordinator_endpoint() ;
  const std::string& coordinator_endpoint() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_coordinator_endpoint(Arg_&& arg, Args_... args);
  std::string* mutable_coordinator_endpoint();
  PROTOBUF_NODISCARD std::string* release_coordinator_endpoint();
  void set_allocated_coordinator_endpoint(std::string* value);

  private:
  const std::string& _internal_coordinator_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coordinator_endpoint(
      const std::string& value);
  std::string* _internal_mutable_coordinator_endpoint();

  public:
  // int32 stage_index = 2;
  void clear_stage_index() ;
  ::int32_t stage_index() const;
  void set_stage_index(::int32_t value);

  private:
  ::int32_t _internal_stage_index() const;
  void _internal_set_stage_index(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tpipeline.proto.StageConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      119, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StageConfig& from_msg);
    ::google::protobuf::internal::ArenaStringPtr stage_id_;
    ::google::protobuf::internal::ArenaStringPtr model_config_json_;
    ::google::protobuf::internal::ArenaStringPtr next_stage_endpoint_;
    ::google::protobuf::internal::ArenaStringPtr prev_stage_endpoint_;
    ::google::protobuf::internal::ArenaStringPtr coordinator_endpoint_;
    ::int32_t stage_index_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pipeline_2eproto;
};
// -------------------------------------------------------------------

class Task final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tpipeline.proto.Task) */ {
 public:
  inline Task() : Task(nullptr) {}
  ~Task() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Task* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Task));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Task(
      ::google::protobuf::internal::ConstantInitialized);

  inline Task(const Task& from) : Task(nullptr, from) {}
  inline Task(Task&& from) noexcept
      : Task(nullptr, std::move(from)) {}
  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  inline Task& operator=(Task&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Task& default_instance() {
    return *internal_default_instance();
  }
  static inline const Task* internal_default_instance() {
    return reinterpret_cast<const Task*>(
        &_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Task& a, Task& b) { a.Swap(&b); }
  inline void Swap(Task* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Task* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Task* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Task>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Task& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Task& from) { Task::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Task* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tpipeline.proto.Task"; }

 protected:
  explicit Task(::google::protobuf::Arena* arena);
  Task(::google::protobuf::Arena* arena, const Task& from);
  Task(::google::protobuf::Arena* arena, Task&& from) noexcept
      : Task(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 2,
    kTypeFieldNumber = 1,
    kMicroBatchIdFieldNumber = 3,
  };
  // .tpipeline.proto.Tensor data = 2;
  bool has_data() const;
  void clear_data() ;
  const ::tpipeline::proto::Tensor& data() const;
  PROTOBUF_NODISCARD ::tpipeline::proto::Tensor* release_data();
  ::tpipeline::proto::Tensor* mutable_data();
  void set_allocated_data(::tpipeline::proto::Tensor* value);
  void unsafe_arena_set_allocated_data(::tpipeline::proto::Tensor* value);
  ::tpipeline::proto::Tensor* unsafe_arena_release_data();

  private:
  const ::tpipeline::proto::Tensor& _internal_data() const;
  ::tpipeline::proto::Tensor* _internal_mutable_data();

  public:
  // .tpipeline.proto.TaskType type = 1;
  void clear_type() ;
  ::tpipeline::proto::TaskType type() const;
  void set_type(::tpipeline::proto::TaskType value);

  private:
  ::tpipeline::proto::TaskType _internal_type() const;
  void _internal_set_type(::tpipeline::proto::TaskType value);

  public:
  // uint32 micro_batch_id = 3;
  void clear_micro_batch_id() ;
  ::uint32_t micro_batch_id() const;
  void set_micro_batch_id(::uint32_t value);

  private:
  ::uint32_t _internal_micro_batch_id() const;
  void _internal_set_micro_batch_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:tpipeline.proto.Task)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Task& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::tpipeline::proto::Tensor* data_;
    int type_;
    ::uint32_t micro_batch_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pipeline_2eproto;
};
// -------------------------------------------------------------------

class Message final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:tpipeline.proto.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Message* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Message));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Message(
      ::google::protobuf::internal::ConstantInitialized);

  inline Message(const Message& from) : Message(nullptr, from) {}
  inline Message(Message&& from) noexcept
      : Message(nullptr, std::move(from)) {}
  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kTask = 10,
    kText = 11,
    kSignal = 12,
    PAYLOAD_NOT_SET = 0,
  };
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
        &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Message& a, Message& b) { a.Swap(&b); }
  inline void Swap(Message* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Message>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Message& from) { Message::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Message* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "tpipeline.proto.Message"; }

 protected:
  explicit Message(::google::protobuf::Arena* arena);
  Message(::google::protobuf::Arena* arena, const Message& from);
  Message(::google::protobuf::Arena* arena, Message&& from) noexcept
      : Message(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSenderIdFieldNumber = 3,
    kRecipientIdFieldNumber = 4,
    kCommandTypeFieldNumber = 1,
    kSequenceNumberFieldNumber = 2,
    kTimestampFieldNumber = 5,
    kTaskFieldNumber = 10,
    kTextFieldNumber = 11,
    kSignalFieldNumber = 12,
  };
  // string sender_id = 3;
  void clear_sender_id() ;
  const std::string& sender_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender_id(Arg_&& arg, Args_... args);
  std::string* mutable_sender_id();
  PROTOBUF_NODISCARD std::string* release_sender_id();
  void set_allocated_sender_id(std::string* value);

  private:
  const std::string& _internal_sender_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_id(
      const std::string& value);
  std::string* _internal_mutable_sender_id();

  public:
  // string recipient_id = 4;
  void clear_recipient_id() ;
  const std::string& recipient_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_recipient_id(Arg_&& arg, Args_... args);
  std::string* mutable_recipient_id();
  PROTOBUF_NODISCARD std::string* release_recipient_id();
  void set_allocated_recipient_id(std::string* value);

  private:
  const std::string& _internal_recipient_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recipient_id(
      const std::string& value);
  std::string* _internal_mutable_recipient_id();

  public:
  // .tpipeline.proto.CommandType command_type = 1;
  void clear_command_type() ;
  ::tpipeline::proto::CommandType command_type() const;
  void set_command_type(::tpipeline::proto::CommandType value);

  private:
  ::tpipeline::proto::CommandType _internal_command_type() const;
  void _internal_set_command_type(::tpipeline::proto::CommandType value);

  public:
  // uint32 sequence_number = 2;
  void clear_sequence_number() ;
  ::uint32_t sequence_number() const;
  void set_sequence_number(::uint32_t value);

  private:
  ::uint32_t _internal_sequence_number() const;
  void _internal_set_sequence_number(::uint32_t value);

  public:
  // uint64 timestamp = 5;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // .tpipeline.proto.Task task = 10;
  bool has_task() const;
  private:
  bool _internal_has_task() const;

  public:
  void clear_task() ;
  const ::tpipeline::proto::Task& task() const;
  PROTOBUF_NODISCARD ::tpipeline::proto::Task* release_task();
  ::tpipeline::proto::Task* mutable_task();
  void set_allocated_task(::tpipeline::proto::Task* value);
  void unsafe_arena_set_allocated_task(::tpipeline::proto::Task* value);
  ::tpipeline::proto::Task* unsafe_arena_release_task();

  private:
  const ::tpipeline::proto::Task& _internal_task() const;
  ::tpipeline::proto::Task* _internal_mutable_task();

  public:
  // string text = 11;
  bool has_text() const;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* value);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // bool signal = 12;
  bool has_signal() const;
  void clear_signal() ;
  bool signal() const;
  void set_signal(bool value);

  private:
  bool _internal_signal() const;
  void _internal_set_signal(bool value);

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:tpipeline.proto.Message)
 private:
  class _Internal;
  void set_has_task();
  void set_has_text();
  void set_has_signal();
  inline bool has_payload() const;
  inline void clear_has_payload();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 1,
      65, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Message& from_msg);
    ::google::protobuf::internal::ArenaStringPtr sender_id_;
    ::google::protobuf::internal::ArenaStringPtr recipient_id_;
    int command_type_;
    ::uint32_t sequence_number_;
    ::uint64_t timestamp_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::tpipeline::proto::Task* task_;
      ::google::protobuf::internal::ArenaStringPtr text_;
      bool signal_;
    } payload_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pipeline_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Tensor

// repeated uint32 shape = 1;
inline int Tensor::_internal_shape_size() const {
  return _internal_shape().size();
}
inline int Tensor::shape_size() const {
  return _internal_shape_size();
}
inline void Tensor::clear_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_.Clear();
}
inline ::uint32_t Tensor::shape(int index) const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Tensor.shape)
  return _internal_shape().Get(index);
}
inline void Tensor::set_shape(int index, ::uint32_t value) {
  _internal_mutable_shape()->Set(index, value);
  // @@protoc_insertion_point(field_set:tpipeline.proto.Tensor.shape)
}
inline void Tensor::add_shape(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_shape()->Add(value);
  // @@protoc_insertion_point(field_add:tpipeline.proto.Tensor.shape)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Tensor::shape() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:tpipeline.proto.Tensor.shape)
  return _internal_shape();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Tensor::mutable_shape()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:tpipeline.proto.Tensor.shape)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_shape();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>&
Tensor::_internal_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Tensor::_internal_mutable_shape() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.shape_;
}

// bytes data = 2;
inline void Tensor::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Tensor::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Tensor.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Tensor::set_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tpipeline.proto.Tensor.data)
}
inline std::string* Tensor::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:tpipeline.proto.Tensor.data)
  return _s;
}
inline const std::string& Tensor::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_.Get();
}
inline void Tensor::_internal_set_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Set(value, GetArena());
}
inline std::string* Tensor::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* Tensor::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tpipeline.proto.Tensor.data)
  return _impl_.data_.Release();
}
inline void Tensor::set_allocated_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:tpipeline.proto.Tensor.data)
}

// string dtype = 3;
inline void Tensor::clear_dtype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dtype_.ClearToEmpty();
}
inline const std::string& Tensor::dtype() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Tensor.dtype)
  return _internal_dtype();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Tensor::set_dtype(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dtype_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tpipeline.proto.Tensor.dtype)
}
inline std::string* Tensor::mutable_dtype() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dtype();
  // @@protoc_insertion_point(field_mutable:tpipeline.proto.Tensor.dtype)
  return _s;
}
inline const std::string& Tensor::_internal_dtype() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dtype_.Get();
}
inline void Tensor::_internal_set_dtype(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dtype_.Set(value, GetArena());
}
inline std::string* Tensor::_internal_mutable_dtype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.dtype_.Mutable( GetArena());
}
inline std::string* Tensor::release_dtype() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tpipeline.proto.Tensor.dtype)
  return _impl_.dtype_.Release();
}
inline void Tensor::set_allocated_dtype(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dtype_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.dtype_.IsDefault()) {
    _impl_.dtype_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:tpipeline.proto.Tensor.dtype)
}

// -------------------------------------------------------------------

// Task

// .tpipeline.proto.TaskType type = 1;
inline void Task::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::tpipeline::proto::TaskType Task::type() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Task.type)
  return _internal_type();
}
inline void Task::set_type(::tpipeline::proto::TaskType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:tpipeline.proto.Task.type)
}
inline ::tpipeline::proto::TaskType Task::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tpipeline::proto::TaskType>(_impl_.type_);
}
inline void Task::_internal_set_type(::tpipeline::proto::TaskType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .tpipeline.proto.Tensor data = 2;
inline bool Task::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline void Task::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.data_ != nullptr) _impl_.data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::tpipeline::proto::Tensor& Task::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::tpipeline::proto::Tensor* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::tpipeline::proto::Tensor&>(::tpipeline::proto::_Tensor_default_instance_);
}
inline const ::tpipeline::proto::Tensor& Task::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Task.data)
  return _internal_data();
}
inline void Task::unsafe_arena_set_allocated_data(::tpipeline::proto::Tensor* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = reinterpret_cast<::tpipeline::proto::Tensor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tpipeline.proto.Task.data)
}
inline ::tpipeline::proto::Tensor* Task::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tpipeline::proto::Tensor* released = _impl_.data_;
  _impl_.data_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::tpipeline::proto::Tensor* Task::unsafe_arena_release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tpipeline.proto.Task.data)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::tpipeline::proto::Tensor* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::tpipeline::proto::Tensor* Task::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.data_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::tpipeline::proto::Tensor>(GetArena());
    _impl_.data_ = reinterpret_cast<::tpipeline::proto::Tensor*>(p);
  }
  return _impl_.data_;
}
inline ::tpipeline::proto::Tensor* Task::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::tpipeline::proto::Tensor* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:tpipeline.proto.Task.data)
  return _msg;
}
inline void Task::set_allocated_data(::tpipeline::proto::Tensor* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.data_ = reinterpret_cast<::tpipeline::proto::Tensor*>(value);
  // @@protoc_insertion_point(field_set_allocated:tpipeline.proto.Task.data)
}

// uint32 micro_batch_id = 3;
inline void Task::clear_micro_batch_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.micro_batch_id_ = 0u;
}
inline ::uint32_t Task::micro_batch_id() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Task.micro_batch_id)
  return _internal_micro_batch_id();
}
inline void Task::set_micro_batch_id(::uint32_t value) {
  _internal_set_micro_batch_id(value);
  // @@protoc_insertion_point(field_set:tpipeline.proto.Task.micro_batch_id)
}
inline ::uint32_t Task::_internal_micro_batch_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.micro_batch_id_;
}
inline void Task::_internal_set_micro_batch_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.micro_batch_id_ = value;
}

// -------------------------------------------------------------------

// Message

// .tpipeline.proto.CommandType command_type = 1;
inline void Message::clear_command_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.command_type_ = 0;
}
inline ::tpipeline::proto::CommandType Message::command_type() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Message.command_type)
  return _internal_command_type();
}
inline void Message::set_command_type(::tpipeline::proto::CommandType value) {
  _internal_set_command_type(value);
  // @@protoc_insertion_point(field_set:tpipeline.proto.Message.command_type)
}
inline ::tpipeline::proto::CommandType Message::_internal_command_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::tpipeline::proto::CommandType>(_impl_.command_type_);
}
inline void Message::_internal_set_command_type(::tpipeline::proto::CommandType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.command_type_ = value;
}

// uint32 sequence_number = 2;
inline void Message::clear_sequence_number() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sequence_number_ = 0u;
}
inline ::uint32_t Message::sequence_number() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Message.sequence_number)
  return _internal_sequence_number();
}
inline void Message::set_sequence_number(::uint32_t value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:tpipeline.proto.Message.sequence_number)
}
inline ::uint32_t Message::_internal_sequence_number() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sequence_number_;
}
inline void Message::_internal_set_sequence_number(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sequence_number_ = value;
}

// string sender_id = 3;
inline void Message::clear_sender_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sender_id_.ClearToEmpty();
}
inline const std::string& Message::sender_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Message.sender_id)
  return _internal_sender_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Message::set_sender_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sender_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tpipeline.proto.Message.sender_id)
}
inline std::string* Message::mutable_sender_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sender_id();
  // @@protoc_insertion_point(field_mutable:tpipeline.proto.Message.sender_id)
  return _s;
}
inline const std::string& Message::_internal_sender_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sender_id_.Get();
}
inline void Message::_internal_set_sender_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sender_id_.Set(value, GetArena());
}
inline std::string* Message::_internal_mutable_sender_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sender_id_.Mutable( GetArena());
}
inline std::string* Message::release_sender_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tpipeline.proto.Message.sender_id)
  return _impl_.sender_id_.Release();
}
inline void Message::set_allocated_sender_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sender_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.sender_id_.IsDefault()) {
    _impl_.sender_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:tpipeline.proto.Message.sender_id)
}

// string recipient_id = 4;
inline void Message::clear_recipient_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recipient_id_.ClearToEmpty();
}
inline const std::string& Message::recipient_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Message.recipient_id)
  return _internal_recipient_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Message::set_recipient_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recipient_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tpipeline.proto.Message.recipient_id)
}
inline std::string* Message::mutable_recipient_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_recipient_id();
  // @@protoc_insertion_point(field_mutable:tpipeline.proto.Message.recipient_id)
  return _s;
}
inline const std::string& Message::_internal_recipient_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.recipient_id_.Get();
}
inline void Message::_internal_set_recipient_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recipient_id_.Set(value, GetArena());
}
inline std::string* Message::_internal_mutable_recipient_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.recipient_id_.Mutable( GetArena());
}
inline std::string* Message::release_recipient_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tpipeline.proto.Message.recipient_id)
  return _impl_.recipient_id_.Release();
}
inline void Message::set_allocated_recipient_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recipient_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.recipient_id_.IsDefault()) {
    _impl_.recipient_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:tpipeline.proto.Message.recipient_id)
}

// uint64 timestamp = 5;
inline void Message::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t Message::timestamp() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Message.timestamp)
  return _internal_timestamp();
}
inline void Message::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:tpipeline.proto.Message.timestamp)
}
inline ::uint64_t Message::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void Message::_internal_set_timestamp(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// .tpipeline.proto.Task task = 10;
inline bool Message::has_task() const {
  return payload_case() == kTask;
}
inline bool Message::_internal_has_task() const {
  return payload_case() == kTask;
}
inline void Message::set_has_task() {
  _impl_._oneof_case_[0] = kTask;
}
inline void Message::clear_task() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kTask) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.task_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.task_);
    }
    clear_has_payload();
  }
}
inline ::tpipeline::proto::Task* Message::release_task() {
  // @@protoc_insertion_point(field_release:tpipeline.proto.Message.task)
  if (payload_case() == kTask) {
    clear_has_payload();
    auto* temp = _impl_.payload_.task_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.task_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::tpipeline::proto::Task& Message::_internal_task() const {
  return payload_case() == kTask ? *_impl_.payload_.task_ : reinterpret_cast<::tpipeline::proto::Task&>(::tpipeline::proto::_Task_default_instance_);
}
inline const ::tpipeline::proto::Task& Message::task() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Message.task)
  return _internal_task();
}
inline ::tpipeline::proto::Task* Message::unsafe_arena_release_task() {
  // @@protoc_insertion_point(field_unsafe_arena_release:tpipeline.proto.Message.task)
  if (payload_case() == kTask) {
    clear_has_payload();
    auto* temp = _impl_.payload_.task_;
    _impl_.payload_.task_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Message::unsafe_arena_set_allocated_task(::tpipeline::proto::Task* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_task();
    _impl_.payload_.task_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tpipeline.proto.Message.task)
}
inline ::tpipeline::proto::Task* Message::_internal_mutable_task() {
  if (payload_case() != kTask) {
    clear_payload();
    set_has_task();
    _impl_.payload_.task_ =
        ::google::protobuf::Message::DefaultConstruct<::tpipeline::proto::Task>(GetArena());
  }
  return _impl_.payload_.task_;
}
inline ::tpipeline::proto::Task* Message::mutable_task() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::tpipeline::proto::Task* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:tpipeline.proto.Message.task)
  return _msg;
}

// string text = 11;
inline bool Message::has_text() const {
  return payload_case() == kText;
}
inline void Message::set_has_text() {
  _impl_._oneof_case_[0] = kText;
}
inline void Message::clear_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kText) {
    _impl_.payload_.text_.Destroy();
    clear_has_payload();
  }
}
inline const std::string& Message::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Message.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Message::set_text(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() != kText) {
    clear_payload();

    set_has_text();
    _impl_.payload_.text_.InitDefault();
  }
  _impl_.payload_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tpipeline.proto.Message.text)
}
inline std::string* Message::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:tpipeline.proto.Message.text)
  return _s;
}
inline const std::string& Message::_internal_text() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (payload_case() != kText) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.payload_.text_.Get();
}
inline void Message::_internal_set_text(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() != kText) {
    clear_payload();

    set_has_text();
    _impl_.payload_.text_.InitDefault();
  }
  _impl_.payload_.text_.Set(value, GetArena());
}
inline std::string* Message::_internal_mutable_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() != kText) {
    clear_payload();

    set_has_text();
    _impl_.payload_.text_.InitDefault();
  }
  return _impl_.payload_.text_.Mutable( GetArena());
}
inline std::string* Message::release_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tpipeline.proto.Message.text)
  if (payload_case() != kText) {
    return nullptr;
  }
  clear_has_payload();
  return _impl_.payload_.text_.Release();
}
inline void Message::set_allocated_text(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_payload()) {
    clear_payload();
  }
  if (value != nullptr) {
    set_has_text();
    _impl_.payload_.text_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:tpipeline.proto.Message.text)
}

// bool signal = 12;
inline bool Message::has_signal() const {
  return payload_case() == kSignal;
}
inline void Message::set_has_signal() {
  _impl_._oneof_case_[0] = kSignal;
}
inline void Message::clear_signal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kSignal) {
    _impl_.payload_.signal_ = false;
    clear_has_payload();
  }
}
inline bool Message::signal() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.Message.signal)
  return _internal_signal();
}
inline void Message::set_signal(bool value) {
  if (payload_case() != kSignal) {
    clear_payload();
    set_has_signal();
  }
  _impl_.payload_.signal_ = value;
  // @@protoc_insertion_point(field_set:tpipeline.proto.Message.signal)
}
inline bool Message::_internal_signal() const {
  if (payload_case() == kSignal) {
    return _impl_.payload_.signal_;
  }
  return false;
}

inline bool Message::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Message::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Message::PayloadCase Message::payload_case() const {
  return Message::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// StageConfig

// string stage_id = 1;
inline void StageConfig::clear_stage_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stage_id_.ClearToEmpty();
}
inline const std::string& StageConfig::stage_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tpipeline.proto.StageConfig.stage_id)
  return _internal_stage_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StageConfig::set_stage_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stage_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tpipeline.proto.StageConfig.stage_id)
}
inline std::string* StageConfig::mutable_stage_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_stage_id();
  // @@protoc_insertion_point(field_mutable:tpipeline.proto.StageConfig.stage_id)
  return _s;
}
inline const std::string& StageConfig::_internal_stage_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stage_id_.Get();
}
inline void StageConfig::_internal_set_stage_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stage_id_.Set(value, GetArena());
}
inline std::string* StageConfig::_internal_mutable_stage_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.stage_id_.Mutable( GetArena());
}
inline std::string* StageConfig::release_stage_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tpipeline.proto.StageConfig.stage_id)
  return _impl_.stage_id_.Release();
}
inline void StageConfig::set_allocated_stage_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stage_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.stage_id_.IsDefault()) {
    _impl_.stage_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:tpipeline.proto.StageConfig.stage_id)
}

// int32 stage_index = 2;
inline void StageConfig::clear_stage_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stage_index_ = 0;
}
inline ::int32_t StageConfig::stage_index() const {
  // @@protoc_insertion_point(field_get:tpipeline.proto.StageConfig.stage_index)
  return _internal_stage_index();
}
inline void StageConfig::set_stage_index(::int32_t value) {
  _internal_set_stage_index(value);
  // @@protoc_insertion_point(field_set:tpipeline.proto.StageConfig.stage_index)
}
inline ::int32_t StageConfig::_internal_stage_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stage_index_;
}
inline void StageConfig::_internal_set_stage_index(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stage_index_ = value;
}

// string model_config_json = 3;
inline void StageConfig::clear_model_config_json() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_config_json_.ClearToEmpty();
}
inline const std::string& StageConfig::model_config_json() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tpipeline.proto.StageConfig.model_config_json)
  return _internal_model_config_json();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StageConfig::set_model_config_json(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_config_json_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tpipeline.proto.StageConfig.model_config_json)
}
inline std::string* StageConfig::mutable_model_config_json() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_model_config_json();
  // @@protoc_insertion_point(field_mutable:tpipeline.proto.StageConfig.model_config_json)
  return _s;
}
inline const std::string& StageConfig::_internal_model_config_json() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.model_config_json_.Get();
}
inline void StageConfig::_internal_set_model_config_json(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_config_json_.Set(value, GetArena());
}
inline std::string* StageConfig::_internal_mutable_model_config_json() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.model_config_json_.Mutable( GetArena());
}
inline std::string* StageConfig::release_model_config_json() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tpipeline.proto.StageConfig.model_config_json)
  return _impl_.model_config_json_.Release();
}
inline void StageConfig::set_allocated_model_config_json(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.model_config_json_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.model_config_json_.IsDefault()) {
    _impl_.model_config_json_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:tpipeline.proto.StageConfig.model_config_json)
}

// string next_stage_endpoint = 4;
inline void StageConfig::clear_next_stage_endpoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_stage_endpoint_.ClearToEmpty();
}
inline const std::string& StageConfig::next_stage_endpoint() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tpipeline.proto.StageConfig.next_stage_endpoint)
  return _internal_next_stage_endpoint();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StageConfig::set_next_stage_endpoint(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_stage_endpoint_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tpipeline.proto.StageConfig.next_stage_endpoint)
}
inline std::string* StageConfig::mutable_next_stage_endpoint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_next_stage_endpoint();
  // @@protoc_insertion_point(field_mutable:tpipeline.proto.StageConfig.next_stage_endpoint)
  return _s;
}
inline const std::string& StageConfig::_internal_next_stage_endpoint() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_stage_endpoint_.Get();
}
inline void StageConfig::_internal_set_next_stage_endpoint(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_stage_endpoint_.Set(value, GetArena());
}
inline std::string* StageConfig::_internal_mutable_next_stage_endpoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.next_stage_endpoint_.Mutable( GetArena());
}
inline std::string* StageConfig::release_next_stage_endpoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tpipeline.proto.StageConfig.next_stage_endpoint)
  return _impl_.next_stage_endpoint_.Release();
}
inline void StageConfig::set_allocated_next_stage_endpoint(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_stage_endpoint_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.next_stage_endpoint_.IsDefault()) {
    _impl_.next_stage_endpoint_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:tpipeline.proto.StageConfig.next_stage_endpoint)
}

// string prev_stage_endpoint = 5;
inline void StageConfig::clear_prev_stage_endpoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prev_stage_endpoint_.ClearToEmpty();
}
inline const std::string& StageConfig::prev_stage_endpoint() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tpipeline.proto.StageConfig.prev_stage_endpoint)
  return _internal_prev_stage_endpoint();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StageConfig::set_prev_stage_endpoint(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prev_stage_endpoint_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tpipeline.proto.StageConfig.prev_stage_endpoint)
}
inline std::string* StageConfig::mutable_prev_stage_endpoint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_prev_stage_endpoint();
  // @@protoc_insertion_point(field_mutable:tpipeline.proto.StageConfig.prev_stage_endpoint)
  return _s;
}
inline const std::string& StageConfig::_internal_prev_stage_endpoint() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prev_stage_endpoint_.Get();
}
inline void StageConfig::_internal_set_prev_stage_endpoint(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prev_stage_endpoint_.Set(value, GetArena());
}
inline std::string* StageConfig::_internal_mutable_prev_stage_endpoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.prev_stage_endpoint_.Mutable( GetArena());
}
inline std::string* StageConfig::release_prev_stage_endpoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tpipeline.proto.StageConfig.prev_stage_endpoint)
  return _impl_.prev_stage_endpoint_.Release();
}
inline void StageConfig::set_allocated_prev_stage_endpoint(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prev_stage_endpoint_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.prev_stage_endpoint_.IsDefault()) {
    _impl_.prev_stage_endpoint_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:tpipeline.proto.StageConfig.prev_stage_endpoint)
}

// string coordinator_endpoint = 6;
inline void StageConfig::clear_coordinator_endpoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.coordinator_endpoint_.ClearToEmpty();
}
inline const std::string& StageConfig::coordinator_endpoint() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:tpipeline.proto.StageConfig.coordinator_endpoint)
  return _internal_coordinator_endpoint();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StageConfig::set_coordinator_endpoint(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.coordinator_endpoint_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:tpipeline.proto.StageConfig.coordinator_endpoint)
}
inline std::string* StageConfig::mutable_coordinator_endpoint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_coordinator_endpoint();
  // @@protoc_insertion_point(field_mutable:tpipeline.proto.StageConfig.coordinator_endpoint)
  return _s;
}
inline const std::string& StageConfig::_internal_coordinator_endpoint() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.coordinator_endpoint_.Get();
}
inline void StageConfig::_internal_set_coordinator_endpoint(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.coordinator_endpoint_.Set(value, GetArena());
}
inline std::string* StageConfig::_internal_mutable_coordinator_endpoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.coordinator_endpoint_.Mutable( GetArena());
}
inline std::string* StageConfig::release_coordinator_endpoint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:tpipeline.proto.StageConfig.coordinator_endpoint)
  return _impl_.coordinator_endpoint_.Release();
}
inline void StageConfig::set_allocated_coordinator_endpoint(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.coordinator_endpoint_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.coordinator_endpoint_.IsDefault()) {
    _impl_.coordinator_endpoint_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:tpipeline.proto.StageConfig.coordinator_endpoint)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace tpipeline


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::tpipeline::proto::TaskType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::tpipeline::proto::TaskType>() {
  return ::tpipeline::proto::TaskType_descriptor();
}
template <>
struct is_proto_enum<::tpipeline::proto::CommandType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::tpipeline::proto::CommandType>() {
  return ::tpipeline::proto::CommandType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // pipeline_2eproto_2epb_2eh
